# タスク: ステップ4 - プリミティブ関数、リスト操作、そして再帰

## 現在の状況

* `fn` (lambda) と変数定義は動いている。
* まだ比較演算子やリスト操作関数がないため、実用的なプログラムが書けない。
* 再帰呼び出し（自分自身の参照）が動かない可能性がある。

## 目標

**「Lisp としてコードが書ける状態」** にする。

1. 比較演算子 (`=`, `<`, `>`) を実装する。
2. リスト操作 (`cons`, `car`, `cdr`, `quote`) を実装する。
3. 再帰呼び出しが動作するように変数参照ロジックを調整する。

## 実装詳細指示

### 1. `src/Spinor/Primitive.hs` (拡張)

以下のプリミティブ関数を追加して `primitiveBindings` に登録してください。

* **比較:**
    * `=`: `VInt` 同士、または `VBool` 同士の比較。戻り値は `VBool`。
    * `<`: `VInt` の比較。
    * `>`: `VInt` の比較。
* **リスト操作:**
    * `cons`: `val` と `list` を受け取り、新しいリストを作る。
    * `car`: リストの先頭要素を返す (空リストならエラー)。
    * `cdr`: リストの先頭以外を返す (空リストならエラー)。
    * `list`: 引数をそのままリスト (`VList`) として返す。
    * `empty?` (または `null?`): リストが空なら `#t`、それ以外なら `#f`。

### 2. `src/Spinor/Eval.hs` (修正)

* **特殊形式 `quote` の実装:**
    * `eval (EList [ESym "quote", expr])`: `expr` を評価せずに、そのまま `Val` に変換して返す。
        * AST (`Expr`) から `Val` への変換ヘルパー関数 (`exprToVal`) が必要になります。
* **変数参照 (`lookup`) のロジック変更 (再帰対応):**
    * 現状の `eval (ESym name)` は、おそらくクロージャ環境のみ、または現在の環境のみを見ている可能性があります。
    * **再帰を可能にするための探索順序:**
        1. ローカルスコープ（関数適用時に拡張された環境）。
        2. クロージャ環境（`VFunc` が持っている環境）。
        3. **グローバル環境（現在の `State` が持っている環境）** ← これが重要！
    * ※ 実装方針: `VFunc` にグローバル環境全体を持たせるのは重いため、`eval` 実行時に「見つからなかったら現在の State (`get`) から探す」というフォールバック処理を入れてください。

## 確認用コード (REPL)

実装後、以下の再帰コードが動くことを確認してください。

```lisp
(define fact (fn (n)
  (if (= n 0)
      1
      (* n (fact (- n 1))))))

(fact 5) ; -> 120

# 実装結果

