# Experimental: Region-based Memory Management Specification

## 1. 概要
一時的なオブジェクトの集合を「リージョン（アリーナ）」と呼ばれるメモリ領域に割り当て、スコープの終了時に領域ごと一括解放する仕組みを導入する。これにより、頻繁なアロケーションと解放のオーバーヘッドを削減し、GC なしでの効率的なメモリ管理を実現する。

## 2. 構文と意味論

### `(with-region r &body body)`
- **機能:** 新しいリージョン（メモリスタック/アリーナ）を作成し、名前 `r` でバインドして `body` を評価する。
- **挙動:** `body` の評価が終わると、`r` 内に割り当てられたすべてのメモリは自動的かつ一括で解放される。
- **制限:** リージョン内で作成されたオブジェクトへの参照を、リージョンの外に持ち出す（Escape）ことは禁止される。

### `(alloc-in r expr)`
- **機能:** `expr` が評価されて生成されるオブジェクト（リスト、文字列、ADT等）のメモリを、明示的にリージョン `r` に割り当てる。

## 3. 型システムと静的解析

### 3.1 リージョンのライフタイム
リージョン `r` にはレキシカルな生存期間（Lifetime）が付与される。

### 3.2 逃避解析 (Escape Analysis)
初期プロトタイプでは、以下のルールを静的に検証する：
- リージョン内で定義された変数を関数の戻り値として返してはならない。
- リージョン外で定義された変数のフィールドに、リージョン内のオブジェクトを代入してはならない。

## 4. コンパイラ (C バックエンド) の統合

### 4.1 Arena Allocator の実装
C 言語ランタイムに以下の構造体と関数を追加する：
- `typedef struct Region { ... } Region;`
- `Region* create_region();`
- `void* region_alloc(Region* r, size_t size);`
- `void destroy_region(Region* r);`

### 4.2 トランスパイル戦略
`with-region` は C のブロックスコープに展開され、リージョンの初期化と破棄のコードが挿入される。

## 5. ドキュメント
- `manual/public/docs/syntax/regions.md` を作成。
- サイドバー (`Sidebar.tsx`) の新しいカテゴリ「Experimental」に追加。
