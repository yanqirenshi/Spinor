# 仕様書 21: Common Lisp 互換機能 (基本)

## 1. 概要

Spinor の実用性を高めるため、Common Lisp (CL) の基本的かつ重要な機能を導入する。
この仕様書では、以下の3つの機能について、その構文と意味論を定める。

1.  **`let` の複数・並列束縛への拡張**
2.  **`setq` (破壊的代入)**
3.  **等価性述語 `eq` と `equal`**

## 2. 機能詳細

### 2.1. `let` の複数・並列束縛

現在の `(let var expr body)` という単一束縛の構文を、CL と同様の複数束縛構文に拡張する。

#### 2.1.1. 構文

```lisp
(let ((var1 init-expr1)
      (var2 init-expr2)
      ...)
  body-expr)
```

- `bindings`: `(var init-expr)` の形式を持つリストのリスト。
- `body-expr`: 束縛が有効なスコープで評価される式。

#### 2.1.2. 意味論: 並列束縛 (Parallel Binding)

`let` は `let*` とは異なり、**並列束縛**を行う。

1.  すべての `init-expr` は、`let` 式自体の外側と同じレキシカル環境で評価される。つまり、ある `init-expr` の評価中に、同じ `let` フォームで束縛される他の `var` を参照することはできない。
2.  すべての `init-expr` の評価が完了した後、各 `var` が対応する評価結果の値に同時に束縛される。
3.  `body-expr` は、この新しい束縛が追加された環境で評価される。

#### 2.1.3. 内部表現の変更提案

この変更に伴い、`Expr` データ型の `ELet` コンストラクタを以下のように変更することを推奨する。

- **変更前:** `ELet Text Expr Expr`
- **変更後:** `ELet [(Text, Expr)] Expr`

#### 2.1.4. 例

```lisp
(let ((x 10))
  (let ((x 2)
        (y (+ x 5))) ; ここで参照される x は外側の 10
    (list x y)))     ; => (2 15)
```

### 2.2. `setq` (破壊的代入)

既存のレキシカル変数の値を変更する機能を提供する。

#### 2.2.1. 構文

```lisp
(setq var new-value-expr)
```

- `var`: 値を変更したい変数のシンボル。**評価されない**。
- `new-value-expr`: 新しい値を生成する式。**評価される**。

#### 2.2.2. 意味論

1.  `new-value-expr` が現在の環境で評価される。
2.  現在のレキシカルスコープ内で `var` という名前の束縛を探す。
3.  束縛が見つかった場合、その値を `new-value-expr` の評価結果で置き換える。
4.  `setq` 式全体の値は、`new-value-expr` の評価結果となる。
5.  `var` が現在のスコープ内に束縛されていない場合、エラーを発生させる。グローバル変数を暗黙的に作成することはない。

#### 2.2.3. 例

```lisp
(let ((counter 0))
  (setq counter (+ counter 1))
  counter) ; => 1
```

### 2.3. 等価性述語 `eq` と `equal`

オブジェクトの等しさを比較するために、目的の異なる2つの述語を導入する。

#### 2.3.1. `eq` (実装レベルでの同一性)

`eq` は、2つの引数が概念的にメモリ上の同じオブジェクトであるかどうかをテストする。

- **構文:** `(eq obj1 obj2)`
- **意味論:**
    - **シンボル, 真偽値, `Nil`:** 同じ値であれば `t` (True) を返す。
    - **数値, 文字列:** 同じ値であれば `t` を返す (これは CL の仕様よりも少し緩い定義だが、Spinor では単純化のためにこの挙動を保証する)。
    - **リスト (`VList`), ユーザー定義型 (`VData`), 関数 (`VFunc`) 等:** 2つの引数が評価の過程で同じオブジェクトとして生成された場合のみ `t` を返す。Haskell の純粋なデータ構造上では参照の同一性を保証することが困難なため、**異なるタイミングで生成された構造的に同じに見えるオブジェクトは `eq` にならない**。この挙動に依存したコードを書くべきではない。

#### 2.3.2. `equal` (構造的な等価性)

`equal` は、2つのオブジェクトが同じ構造と内容を持っているかどうかを再帰的にテストする。

- **構文:** `(equal obj1 obj2)`
- **意味論:**
    - **アトム (数値, 文字列, シンボル, 真偽値):** `eq` と同様に振る舞う。
    - **リスト (`VList`), ユーザー定義型 (`VData`):** 対応する要素を再帰的に `equal` で比較し、すべてが `equal` であれば `t` を返す。
    - **関数 (`VFunc`), マクロ (`VMacro`), MVar (`VMVar`) 等の不透明なオブジェクト:** 常に `nil` (False) を返す。

#### 2.3.3. 実装上の注記

`equal` の意味論を正しく実装するため、`Val` 型に手動で `Eq` インスタンスを定義し、関数等の比較が常に `False` となるように制御する必要がある。
```
