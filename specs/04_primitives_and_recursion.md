# Spinor プリミティブ関数、リスト操作、再帰 仕様

## 1. 概要

Lisp としての実用性を高めるため、基本的なプリミティブ関数群（比較演算、リスト操作など）を拡充する。また、`define` と関数適用時の環境解決メカニズムを利用して、再帰関数を定義・実行する方法について規定する。

## 2. プリミティブ関数

初期環境に、以下のプリミティブ関数が `VPrim` 型の値として登録される。これらの関数は、引数の型や数が不正な場合にはエラーを報告する。

### 2.1. 比較演算

| 関数 | 構文 | 説明 |
| :--- | :--- | :--- |
| `=` | `(= a b)` | `a` と `b` の等価性を評価する。引数は両方が整数、または両方が真偽値である必要がある。 |
| `<` | `(< a b)` | 整数 `a` が整数 `b` より小さい場合に `#t` を返す。 |
| `>` | `(> a b)` | 整数 `a` が整数 `b` より大きい場合に `#t` を返す。 |

### 2.2. 型述語

| 関数 | 構文 | 説明 |
| :--- | :--- | :--- |
| `null?` / `empty?` | `(null? x)` | `x` が空リスト (`VNil` または `VList []`) の場合に `#t` を、それ以外の場合に `#f` を返す。 |

## 3. リスト操作

### 3.1. コンストラクタ

| 関数 | 構文 | 説明 |
| :--- | :--- | :--- |
| `list` | `(list a b ...)` | 任意の数の引数を受け取り、それらを要素とする新しいリスト `(VList [a, b, ...])` を生成する。 |
| `cons` | `(cons head tail)` | 要素 `head` をリスト `tail` の先頭に追加し、新しいリストを生成する。`tail` はリストである必要がある。 |

### 3.2. アクセサ

| 関数 | 構文 | 説明 |
| :--- | :--- | :--- |
| `car` | `(car lst)` | リスト `lst` の先頭要素を返す。`lst` が空リストの場合はエラーとなる。 |
| `cdr` | `(cdr lst)` | リスト `lst` の先頭要素を除いた残りの部分を、新しいリストとして返す。`lst` が空リストの場合はエラーとなる。 |

## 4. 再帰 (Recursion)

Spinor は `letrec` のような特別な再帰用構文を持たない。再帰は `define` による名前束縛と、関数適用時のスコープ解決の仕組みによって実現される。

### 4.1. 実現メカニズム

関数適用（`apply`）時、シンボル（変数や関数名）を解決するための環境は、以下の3つの環境をマージして構築される。これにより、関数は自身のスコープ外にある名前も参照できる。

1.  **ローカル環境**: 関数の仮引数と、呼び出し時に渡された実引数の束縛。最優先で参照される。
2.  **クロージャ環境**: 関数が定義 (`fn`) された時点の環境。これにより、自由変数が解決される。
3.  **グローバル環境**: 関数が呼び出された時点のトップレベル環境。

`define` で定義された関数はグローバル環境に束縛される。関数本体の評価中、関数名（シンボル）の解決は、まずローカルとクロージャ環境で行われる。そこで見つからなければ、フォールバックとしてグローバル環境が探索される。

この仕組みにより、関数本体の中からグローバルに束縛された自分自身の名前を解決できるため、自己再帰が可能となる。

### 4.2. コード例

以下に階乗を計算する再帰関数の例を示す。

```scheme
;; `fact` をグローバル環境に定義する
(define fact
  (fn (n)
    ;; `fact` の関数本体
    (if (= n 0)
        1
        ;; 本体の中からグローバル環境にある `fact` 自身を参照する
        (* n (fact (- n 1))))))

;; 実行
(fact 5) ;; => 120
```
