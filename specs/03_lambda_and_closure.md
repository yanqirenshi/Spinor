# Spinor ユーザー定義関数とクロージャ 仕様

## 1. 概要

Spinor にユーザー定義の関数を作成する機能を追加する。関数は第一級の値 (first-class citizen) であり、変数に束縛したり、他の関数に引数として渡したり、戻り値として返したりすることができる。

この機能は、関数が定義された時点の環境を記憶する「クロージャ」によって実現され、レキシカルスコープ（静的スコープ）を保証する。コード上、このクロージャは `VFunc` という値で表現される。

## 2. データ構造の拡張

### 2.1. `Val` 型への `VFunc` の追加

評価結果を表す `Val` 型に、クロージャを表す `VFunc` コンストラクタが追加されている。

| `Val` コンストラクタ | 格納するデータ | 説明 |
| :--- | :--- | :--- |
| `VFunc` | `[Text]`, `Expr`, `Env` | (仮引数リスト, 関数本体, 定義時環境) を保持するクロージャ。 |

`VFunc` は以下の3つの要素をキャプチャする。
1.  **仮引数リスト (`[Text]`)**: 関数のパラメータ名のリスト。
2.  **関数本体 (`Expr`)**: まだ評価されていない、関数の処理内容を記述した式。
3.  **定義時環境 (`Env`)**: 関数が `fn` 式によって生成された瞬間の環境。これにより、関数本体から自由変数を参照できる。

### 2.2. 型定義の依存関係

`VFunc` が `Env` を保持し、`Env` は `Map Text Val` であるため、`Val` と `Env` の間には型レベルでの相互再帰的な依存関係が生じる。これを解決するため、両方の型定義は同一モジュール内に配置されている。

## 3. 特殊形式 `fn`

`fn` は、新たな関数（クロージャ）を生成するための特殊形式である。

*   **構文**: `fn` は引数の取り方によって複数の形式をサポートする。

    1.  **固定長引数**: `(fn (param1 param2 ...) body-expr)`
        *   仮引数リスト `(param1 ...)` を取り、関数呼び出し時に同数の実引数を必要とする。

    2.  **可変長引数（全キャプチャ）**: `(fn params-symbol body-expr)`
        *   仮引数リストの代わりに単一のシンボル `params-symbol` を置く。
        *   関数呼び出し時のすべての実引数が、`params-symbol` に束縛された単一のリストとして `body-expr` に渡される。

    3.  **可変長引数（ドット記法）**: `(fn (param1 . rest-symbol) body-expr)`
        *   仮引数リストの最後にドット `.` とシンボル `rest-symbol` を置く。
        *   `param1` までの引数は通常通り束縛され、残りのすべての実引数が `rest-symbol` に束縛されたリストになる。

*   **評価ルール**:
    1. `fn` 式が評価されると、評価器は **現在の環境** を取得する。
    2. 仮引数リストと関数本体 `body-expr` は、この時点では評価 **されない**。
    3. 評価器は、1で取得した現在の環境、2の仮引数リストと関数本体から `VFunc` オブジェクトを生成する。
    4. この `VFunc` が `fn` 式全体の評価結果となる。

## 4. 関数適用の拡張

リストの評価ロジック（関数適用）は、`VPrim` に加えて `VFunc` も処理できるように拡張されている。

*   **評価プロセス**:
    1.  リスト `(f arg1 arg2 ...)` の各要素 `f`, `arg1`, `arg2`, ... を（通常のルールに従って）評価する。
    2.  `f` の評価結果が `VFunc(params, body, closure-env)` であることを確認する。
    3.  `bindArgs` のような内部ロジックにより、`params` で定義された形式（固定長、可変長）に従って、評価済みの実引数が仮引数名に束縛された **ローカル環境** を作成する。引数の数や形式が合わない場合はエラーとなる。
    4.  `closure-env` （クロージャがキャプチャした定義時環境）を、3で作成したローカル環境で拡張し、**一時的な実行環境** を構築する。
    5.  この一時的な実行環境の下で、クロージャが保持していた関数本体 `body` を `eval` する。
    6.  `body` の評価結果が、関数呼び出し式 `(f arg1 ...)` 全体の最終的な評価結果となる。

このメカニズムにより、関数本体 `body` は、それが定義された環境の変数を参照でき（レキシカルスコープ）、かつ呼び出し時に渡された引数も利用できる。
