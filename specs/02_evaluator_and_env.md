# Spinor 評価器と環境 仕様

## 1. 概要

評価器 (Evaluator) は、パーサーによって生成された抽象構文木 (`Expr`) を解釈・実行し、最終的な値 (`Val`) を生成するコンポーネントである。評価の過程で、シンボルとその値の対応を環境 (`Env`) を用いて管理する。

## 2. 値 (Value)

`Val` は、式の評価結果を表すデータ型である。

| `Val` コンストラクタ | 説明 |
| :--- | :--- |
| `VInt Integer` | 整数値。 |
| `VBool Bool` | 真偽値。 |
| `VStr Text` | 文字列値。 |
| `VSym Text` | `quote` された結果としてのシンボル。評価されない。 |
| `VPrim Text PrimFunc` | プリミティブ関数（組み込み関数）。名前と実装を持つ。 |
| `VFunc [Text] Expr Env` | ユーザー定義関数（クロージャ）。 |
| `VMacro [Text] Expr Env`| ユーザー定義マクロ。 |
| `VList [Val]` | 値のリスト。 |
| `VNil` | 空リストを表す特別な値。 |

## 3. 環境 (Environment)

`Env` は、シンボル (変数名) から評価済みの値 (`Val`) へのマッピングを保持するデータ構造である。

*   **型定義**: `type Env = Map Text Val`
*   **役割**:
    *   `define` によって束縛された変数を保存する。
    *   シンボル参照時に、対応する値を取得するために使われる。
*   **スコープ**: 環境はネスト可能であり、これによりレキシカルスコープが実現される。
*   **初期環境**: REPL の起動時には、以下のプリミティブ関数が登録された初期環境が用意される。
    *   **算術**: `+`, `-`, `*`, `%`
    *   **比較**: `=`, `<`, `>`
    *   **リスト操作**: `cons`, `car`, `cdr`, `list`, `null?`, `empty?`

## 4. 評価モナド (`Eval`)

`Eval` モナドは、状態の更新（環境の変更）、エラーハンドリング、I/O操作を統一的に扱うための評価コンテキストである。

*   **型定義**: `newtype Eval a = Eval { runEval :: StateT Env (ExceptT Text IO) a }`
*   **構成要素**:
    *   `StateT Env`: `define` による環境の変更を状態として管理する。
    *   `ExceptT Text`: 評価時エラー（未定義シンボルなど）を捕捉し、エラーメッセージを伝播させる。
    *   `IO`: `print` 特殊形式などのI/O処理を実行する。

## 5. 評価ロジック (`eval` 関数)

`eval` 関数は `Expr` を入力として受け取り、`Eval` モナド内で評価を行い、結果の `Val` を返す。

### 5.1. アトムの評価

| `Expr` | 評価結果 | 説明 |
| :--- | :--- | :--- |
| `EInt i` | `VInt i` | 整数リテラルは整数値に変換される。 |
| `EBool b` | `VBool b` | 真偽値リテラルは真偽値に変換される。 |
| `EStr s` | `VStr s` | 文字列リテラルは文字列値に変換される。 |
| `ESym s` | `Env` から検索した値 | 現在の環境 `Env` からシンボル `s` を検索する。見つからない場合はエラーとなる。 |

### 5.2. リストの評価

`EList` の評価は、リストの先頭要素によって動作が変わる。

1.  **空リスト**: `()` は `VNil` に評価される。
2.  **特殊形式 (Special Forms)**: リストの先頭が特定のシンボルである場合、通常の関数適用とは異なる特別な評価ルールが適用される。

    | 特殊形式 | 構文 | 評価ルール |
    | :--- | :--- | :--- |
    | `quote` | `(quote expression)` | `expression` を評価せず、その構造を保ったまま `Val` ( `VList`, `VSym` 等) に変換する。 |
    | `define` / `def` | `(define symbol expression)` | `expression` を評価し、その結果を現在の環境で `symbol` に束縛する。`def` はエイリアス。 |
    | `if` | `(if cond-expr then-expr else-expr)` | `cond-expr` を評価する。結果が `VBool False` または `VNil` でなければ `then-expr` を評価し、そうでなければ `else-expr` を評価する。 |
    | `fn` | `(fn (param ...) body)` | ユーザー定義関数（クロージャ）を生成する。この時点では関数本体 `body` は評価されない。詳細はクロージャの仕様で規定する。 |
    | `mac` | `(mac (param ...) body)` | ユーザー定義マクロを生成する。 |
    | `print` | `(print expression)` | `expression` を評価し、その結果を標準出力に表示する。評価結果自体も返す。 |

3.  **関数適用 (Function Application)**: リストが特殊形式でない場合、関数適用として扱われる。
    1.  リストの全要素（先頭の関数と後続の引数）を左から右へ順に評価する。
    2.  先頭要素の評価結果が適用可能な値（`VPrim`, `VFunc`）であることを確認する。
    3.  引数の評価結果を、その関数に適用する。
